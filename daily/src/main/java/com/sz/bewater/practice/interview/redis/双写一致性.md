当我们要更新数据库中的数据 如何做到缓存和数据库中的数据 保持一致呢  是先删除缓存再更新数据库?  还是先更新数据库再删除缓存?
设定 cache和db中的数据一开始都是10  现要将数据修改成20
假如是先删除缓存再更新数据库:  一个线程a来执行这个操作 a先删除缓存在更新数据库 线程b来读取数据 发现缓存被删了 就去读取数据库的数据 这时候线程a还没来得及更新数据库
                        线程b读到修改之前的数据10 然后更新缓存为10 然后线程a更新了数据库中的数据为20  这时候缓存和db中的数据不一致
假如是先更新db再删除cache: 线程a来读数据 发现缓存中数据过期了 就去读db中的数据10 然后准备写入到缓存中  这时候线程b来了 去执行更新db再删除cache操作
                        数据库中的数据被更新成了20 缓存中此时没数据  然后a将10写入到缓存 这时候缓存和db数据不一致
所以无论是先操作数据库还是先删除缓存 在考虑到多线程情况下 都有可能导致缓存和db数据不一致

延时双删:
    删除缓存-->更新数据库--->(延时)删除缓存
    第二次删除缓存很好理解:为了避免在更新数据库操作时 有读操作造成缓存中是脏数据 需要再删一遍
    延时:一方面是为了数据库主从同步(假如数据库是主从架构) 等待主库数据同步到从库  二方面也是等待更新数据库期间读操作将脏(旧)数据重新写入到缓存的操作完成
    能保证db和cache数据的最终一致性吗????  不一定  因为这个延时的时间不好控制 控制不好最终结果还是有可能不一致的

解决方案:
    1.保证强一致性: 加互斥锁(保证操作的原子性) 例如redisson提供的readWriteLock(读读共享 读写互斥 写写互斥) 读写锁 读共享 写互斥(写的时候连读都阻塞) 保证了数据的强一致性
                    允许多个线程持有同一把读锁  同一时间只允许一个线程持有写锁 当写锁被持有的时候 无法尝试获得读锁或者写锁 必须等待写锁释放
    2.保证最终一致性(允许短暂的数据不一致):a.消息队列 当数据库更新时 利用消息队列通知缓存更新数据
                                    b.canal  使用阿里提供的canal canal服务会将自己伪装成数据库的节点 监听binlog日志 将数据库的变更操作同步给redis中 最终达成数据的一致性


读写锁保证双写一致性 在读多写少的情况下 效率较高  在读少写多的情况下效率比较低