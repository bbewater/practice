请求流程: 请求-->缓存(存在则直接返回,不存在则请求db)-->db(存在则先添加到cache然后返回,不存在则报错等后续处理)

缓存穿透: 访问既不存在于缓存也不存在于db的数据 导致每次请求都打在了db上(恶意攻击) 导致高并发情况下 db压力过大而宕机
        解决方案: 1.将这个不存在的数据缓存下来 以null返回  但是可能造成数据不一致(下次可能这个数据就存在了)
                2.布隆过滤器(redisson的实现说明下 见com.sz.bewater.practice.interview.redis.BloomFilter)

缓存击穿: 热点数据设置了过期时间,当热点数据过期这个时间点,刚好有大量请求过来请求这个热点数据,则这些请求则会砸在db上,造成db压力过大
        解决方案: 1.设置互斥锁(当一个线程过来请求热点数据,发现过期了.则去获取一个互斥锁,然后去做缓存重建操作,在这个期间内,其他线程将会阻塞直到缓存重建完成)
                   特点:保证了强一致性,但是性能较差
                2.设置逻辑过期时间(给热点数据添加过期时间字段expire,当一个线程过来发现数据过期,则该线程会另一个线程,委托这个线程去做缓存重建操作,
)                       自己则会直接返回过期数据,在缓存重建期间,其他线程都会返回过期的数据,直到缓存重建完成.所有线程都是非阻塞的)
                   特点:保证了高可用,但是不保证数据强一致

缓存雪崩: 某一时刻大量的热点数据同时过期、或者是redis服务宕机，导致db压力瞬间激增
        解决方案：1.热点数据设置随机过期时间
                2.redis高可用（哨兵模式、集群模式）
                3.使用nginx或者是springcloud gateway做限流降级